#!/usr/bin/env python3
import os
import judge
from time import process_time
from queue import PriorityQueue


def read_input():
    inputs = list()  # a list containing inputs from all files
    for file in input_files:
        input = list()  # input from a single file
        with open(file) as fh:
            for i in range(0, int(fh.readline())):
                input.append(list())
                for i in range(0, int(fh.readline())):
                    input[-1].append([int(i) for i in fh.readline().split()])
        inputs.append(input)
    return inputs


def put_square(A, queue, jungle, i, j, cost):
    if A[i][j] is False:
        queue.put((cost + jungle[i][j], i, j))
        A[i][j] = True


def find_way_out(jungle):
    """finds the fastest way out of the jungle"""
    queue = PriorityQueue()
    A = [list() for row in jungle]  # was jungle[i][j] added to the queue yet?
    # initialize A and find the starting square
    for i in range(0, len(jungle)):
        for j in range(0, len(jungle)):
            A[i].append(False)
            if jungle[i][j] == 0:
                A[i][j] = True
                square = (0, i, j)
    # square[0] == cost to reach this square
    # square[1] == i coordinate of this square
    # square[2] == j coordinate of this square
    while square[1] != 0 and square[1] != len(jungle) - 1 and square[2] != 0 and square[2] != len(jungle) - 1:
        # add the surrounding four squares
        put_square(A, queue, jungle, square[1] + 1, square[2], square[0])
        put_square(A, queue, jungle, square[1] - 1, square[2], square[0])
        put_square(A, queue, jungle, square[1], square[2] + 1, square[0])
        put_square(A, queue, jungle, square[1], square[2] - 1, square[0])
        # continue with next square
        square = queue.get()
    return square[0]


# path to the local test files
path = "testdata/DnA-jungle/"
input_files = [os.path.join(path, file) for file in os.listdir(path) if file.endswith(".input")]
output_files = [os.path.join(path, file) for file in os.listdir(path) if file.endswith(".output")]
input_files.sort()
output_files.sort()
# inputs from the test files
inputs = read_input()
# outputs generated by the algorithm
start_time = process_time()
outputs = list()
for input in inputs:
    outputs.append([find_way_out(case) for case in input])
end_time = process_time()

judge.run(output_files, outputs, end_time - start_time)
